# ðŸš« [à¸ªà¸³à¸„à¸±à¸] à¸«à¹‰à¸²à¸¡à¹ƒà¸ªà¹ˆà¸«à¸£à¸·à¸­ generate Codacy CLI/Scanner à¹ƒà¸™ workflow à¸™à¸µà¹‰
# âœ… [à¸šà¸±à¸‡à¸„à¸±à¸š] à¹ƒà¸Šà¹‰ ESLint (JS/TS) à¸«à¸£à¸·à¸­ Flake8 (Python) à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™à¸ªà¸³à¸«à¸£à¸±à¸š static analysis
# à¸«à¸²à¸à¸žà¸š Codacy, PR à¸ˆà¸°à¸–à¸¹à¸à¸›à¸à¸´à¹€à¸ªà¸˜à¸—à¸±à¸™à¸—à¸µ
#
# à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡ Workflow à¸—à¸µà¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡ (à¸ªà¸³à¸«à¸£à¸±à¸š JS/TS):
# name: Lint & Static Analysis
# on: [push, pull_request]
# jobs:
#   lint:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       - uses: actions/setup-node@v4
#         with:
#           node-version: '20'
#       - run: npm ci
#       - run: npx eslint . --ext .js,.ts --max-warnings=0

name: Smart Documentation Sync

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    
jobs:
  smart-sync:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build

    # === à¸£à¸°à¸šà¸šà¸—à¸³à¸„à¸§à¸²à¸¡à¸ªà¸°à¸­à¸²à¸”à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´ ===
    - name: Auto Cleanup Test Files
      run: |
        echo "ðŸ§¹ Running auto cleanup..."
        npm run cleanup || echo "âš ï¸ Cleanup failed but continuing..."

    # === à¸ªà¸£à¹‰à¸²à¸‡ Cache à¸ªà¸³à¸«à¸£à¸±à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸­à¹ˆà¸²à¸™à¸šà¹ˆà¸­à¸¢ ===
    - name: Generate Project Cache
      run: |
        echo "ðŸ’¾ Generating project cache..."
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        const projectData = {
          timestamp: new Date().toISOString(),
          structure: {},
          tools: [],
          databases: {},
          scripts: {},
          documentation: {}
        };
        
        // à¸­à¹ˆà¸²à¸™ package.json
        try {
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          projectData.scripts = pkg.scripts;
          projectData.dependencies = pkg.dependencies;
          projectData.devDependencies = pkg.devDependencies;
        } catch (e) {}
        
        // à¸ªà¹à¸à¸™à¹„à¸Ÿà¸¥à¹Œà¸ªà¸³à¸„à¸±à¸
        const importantFiles = [
          'README.md', 'ROADMAP-UPDATED.md', 'FRONTEND-API-GUIDE.md',
          '.env.example', 'package.json'
        ];
        
        importantFiles.forEach(file => {
          try {
            if (fs.existsSync(file)) {
              const content = fs.readFileSync(file, 'utf8');
              projectData.documentation[file] = {
                size: content.length,
                lines: content.split('\n').length,
                lastModified: fs.statSync(file).mtime
              };
            }
          } catch (e) {}
        });
        
        // à¸ªà¹à¸à¸™à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­
        const jsFiles = fs.readdirSync('.').filter(f => f.endsWith('.js') && !f.startsWith('test-'));
        projectData.tools = jsFiles.map(f => ({
          name: f,
          size: fs.statSync(f).size,
          lastModified: fs.statSync(f).mtime
        }));
        
        fs.writeFileSync('.github/project-cache.json', JSON.stringify(projectData, null, 2));
        console.log('âœ… Project cache generated');
        "

    # === à¸­à¸±à¸›à¹€à¸”à¸•à¹€à¸­à¸à¸ªà¸²à¸£à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´ ===
    - name: Auto Update Documentation
      run: |
        echo "ðŸ“ Auto updating documentation..."
        
        # à¸­à¸±à¸›à¹€à¸”à¸•à¸ªà¸–à¸´à¸•à¸´à¹‚à¸›à¸£à¹€à¸ˆà¸„
        node -e "
        const fs = require('fs');
        
        // à¸™à¸±à¸šà¸ˆà¸³à¸™à¸§à¸™à¹„à¸Ÿà¸¥à¹Œà¹à¸¥à¸°à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­
        const jsFiles = fs.readdirSync('.').filter(f => f.endsWith('.js') && !f.startsWith('test-'));
        const checkFiles = jsFiles.filter(f => f.startsWith('check-'));
        const toolFiles = jsFiles.filter(f => !f.startsWith('check-') && !f.startsWith('test-'));
        
        const stats = {
          totalFiles: jsFiles.length,
          checkTools: checkFiles.length,
          otherTools: toolFiles.length,
          updated: new Date().toLocaleString('th-TH')
        };
        
        console.log('ðŸ“Š Project Statistics:');
        console.log('   Total JS Files:', stats.totalFiles);
        console.log('   Check Tools:', stats.checkTools);
        console.log('   Other Tools:', stats.otherTools);
        
        // à¸­à¸±à¸›à¹€à¸”à¸• README footer
        try {
          let readme = fs.readFileSync('README.md', 'utf8');
          const footerRegex = /---\n\*.*à¸­à¸±à¸›à¹€à¸”à¸•à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´.*\*/;
          const newFooter = '---\\n*à¸­à¸±à¸›à¹€à¸”à¸•à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´à¹‚à¸”à¸¢ GitHub Actions | à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”: ' + stats.totalFiles + ' | à¸­à¸±à¸›à¹€à¸”à¸•: ' + stats.updated + '*';
          
          if (footerRegex.test(readme)) {
            readme = readme.replace(footerRegex, newFooter);
          } else {
            readme += '\n\n' + newFooter;
          }
          
          fs.writeFileSync('README.md', readme);
          console.log('âœ… README footer updated');
        } catch (e) {
          console.log('âš ï¸ README update failed:', e.message);
        }
        "

    # === à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸ªà¸¸à¸‚à¸ à¸²à¸žà¹‚à¸›à¸£à¹€à¸ˆà¸„ ===
    - name: Project Health Check
      run: |
        echo "ðŸ¥ Running project health check..."
        
        node -e "
        const fs = require('fs');
        
        const healthReport = {
          timestamp: new Date().toISOString(),
          status: 'healthy',
          issues: [],
          recommendations: []
        };
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹„à¸Ÿà¸¥à¹Œà¸ªà¸³à¸„à¸±à¸
        const criticalFiles = [
          'package.json', 'README.md', 'server/app.js', 
          'src/tools/index.ts', '.env.example'
        ];
        
        criticalFiles.forEach(file => {
          if (!fs.existsSync(file)) {
            healthReport.issues.push(\`Missing critical file: \${file}\`);
            healthReport.status = 'warning';
          }
        });
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š dependencies
        try {
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const deps = Object.keys(pkg.dependencies || {});
          
          if (deps.length === 0) {
            healthReport.issues.push('No dependencies found');
          }
          
          // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š scripts à¸—à¸µà¹ˆà¸ªà¸³à¸„à¸±à¸
          const importantScripts = ['build', 'start-gateway', 'cleanup'];
          importantScripts.forEach(script => {
            if (!pkg.scripts || !pkg.scripts[script]) {
              healthReport.issues.push(\`Missing important script: \${script}\`);
            }
          });
          
        } catch (e) {
          healthReport.issues.push('Cannot read package.json');
          healthReport.status = 'error';
        }
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š environment variables
        try {
          const envExample = fs.readFileSync('.env.example', 'utf8');
          const envVars = envExample.match(/^[A-Z_]+=.*/gm) || [];
          
          if (envVars.length < 5) {
            healthReport.recommendations.push('Consider adding more environment variables examples');
          }
        } catch (e) {
          healthReport.issues.push('Cannot read .env.example');
        }
        
        // à¸šà¸±à¸™à¸—à¸¶à¸à¸£à¸²à¸¢à¸‡à¸²à¸™
        fs.writeFileSync('.github/health-report.json', JSON.stringify(healthReport, null, 2));
        
        console.log('ðŸ¥ Health Check Results:');
        console.log('Status:', healthReport.status);
        console.log('Issues:', healthReport.issues.length);
        console.log('Recommendations:', healthReport.recommendations.length);
        
        if (healthReport.issues.length > 0) {
          console.log('âŒ Issues found:');
          healthReport.issues.forEach(issue => console.log('  -', issue));
        }
        
        if (healthReport.recommendations.length > 0) {
          console.log('ðŸ’¡ Recommendations:');
          healthReport.recommendations.forEach(rec => console.log('  -', rec));
        }
        "

    # === à¸ªà¸£à¹‰à¸²à¸‡ API Documentation à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´ ===
    - name: Generate API Documentation
      run: |
        echo "ðŸ“– Generating API documentation..."
        
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        let apiDocs = '# ðŸ“– Auto-Generated API Documentation\n\n';
        apiDocs += \`Generated: \${new Date().toLocaleString('th-TH')}\n\n\`;
        
        // à¸ªà¹à¸à¸™ server endpoints
        try {
          const serverPath = 'server/app.js';
          if (fs.existsSync(serverPath)) {
            const serverContent = fs.readFileSync(serverPath, 'utf8');
            
            // à¸«à¸² endpoints
            const endpoints = [];
            const routeMatches = serverContent.match(/app\.(get|post|put|delete)\(['\"](.*?)['\"]/g) || [];
            
            routeMatches.forEach(match => {
              const methodMatch = match.match(/app\.(\w+)/);
              const pathMatch = match.match(/['\"](.*?)['\"]$/);
              
              if (methodMatch && pathMatch) {
                endpoints.push({
                  method: methodMatch[1].toUpperCase(),
                  path: pathMatch[1]
                });
              }
            });
            
            if (endpoints.length > 0) {
              apiDocs += '## ðŸŒ API Endpoints\n\n';
              endpoints.forEach(ep => {
                apiDocs += \`- **\${ep.method}** \\\`\${ep.path}\\\`\n\`;
              });
              apiDocs += '\n';
            }
          }
        } catch (e) {
          console.log('âš ï¸ Could not scan server endpoints');
        }
        
        // à¸ªà¹à¸à¸™ MCP tools
        try {
          const toolsPath = 'src/tools';
          if (fs.existsSync(toolsPath)) {
            const toolFiles = fs.readdirSync(toolsPath).filter(f => f.endsWith('.ts'));
            
            if (toolFiles.length > 0) {
              apiDocs += '## ðŸ› ï¸ MCP Tools\n\n';
              toolFiles.forEach(file => {
                apiDocs += \`- \\\`\${file}\\\`\n\`;
              });
              apiDocs += '\n';
            }
          }
        } catch (e) {
          console.log('âš ï¸ Could not scan MCP tools');
        }
        
        // à¸ªà¹à¸à¸™ scripts
        try {
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          if (pkg.scripts) {
            apiDocs += '## âš¡ Available Scripts\n\n';
            Object.entries(pkg.scripts).forEach(([name, command]) => {
              apiDocs += \`- **\${name}**: \\\`\${command}\\\`\n\`;
            });
            apiDocs += '\n';
          }
        } catch (e) {
          console.log('âš ï¸ Could not read scripts');
        }
        
        fs.writeFileSync('.github/api-docs.md', apiDocs);
        console.log('âœ… API documentation generated');
        "

    # === à¸ªà¸£à¹‰à¸²à¸‡ Performance Report ===
    - name: Performance Analysis
      run: |
        echo "âš¡ Analyzing performance..."
        
        node -e "
        const fs = require('fs');
        
        const perfReport = {
          timestamp: new Date().toISOString(),
          fileAnalysis: {},
          recommendations: []
        };
        
        // à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸‚à¸™à¸²à¸”à¹„à¸Ÿà¸¥à¹Œ
        const jsFiles = fs.readdirSync('.').filter(f => f.endsWith('.js'));
        let totalSize = 0;
        
        jsFiles.forEach(file => {
          const stats = fs.statSync(file);
          const sizeKB = Math.round(stats.size / 1024);
          
          perfReport.fileAnalysis[file] = {
            sizeKB: sizeKB,
            lines: fs.readFileSync(file, 'utf8').split('\n').length
          };
          
          totalSize += stats.size;
          
          // à¹à¸™à¸°à¸™à¸³à¸–à¹‰à¸²à¹„à¸Ÿà¸¥à¹Œà¹ƒà¸«à¸à¹ˆà¹€à¸à¸´à¸™à¹„à¸›
          if (sizeKB > 50) {
            perfReport.recommendations.push(\`Consider breaking down \${file} (large file: \${sizeKB}KB)\`);
          }
        });
        
        perfReport.totalSizeKB = Math.round(totalSize / 1024);
        
        // à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ dependencies
        try {
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const deps = Object.keys(pkg.dependencies || {});
          const devDeps = Object.keys(pkg.devDependencies || {});
          
          perfReport.dependencyAnalysis = {
            production: deps.length,
            development: devDeps.length,
            total: deps.length + devDeps.length
          };
          
          if (deps.length > 20) {
            perfReport.recommendations.push('Consider reducing production dependencies');
          }
          
        } catch (e) {}
        
        fs.writeFileSync('.github/performance-report.json', JSON.stringify(perfReport, null, 2));
        
        console.log('âš¡ Performance Analysis:');
        console.log('Total Size:', perfReport.totalSizeKB, 'KB');
        console.log('Files Analyzed:', Object.keys(perfReport.fileAnalysis).length);
        console.log('Recommendations:', perfReport.recommendations.length);
        "

    # === Commit à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡ ===
    - name: Commit Auto Updates
      if: github.event_name == 'push' # Run only on push events
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Actions Bot"
        
        # à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
        if ! git diff --quiet; then
          echo "ðŸ“ Changes detected, committing..."
          # Checkout (or create) the correct branch before committing
          git checkout -B "${{ github.ref_name }}"
          git add .
          git commit -m "ðŸ¤– Auto-update: documentation, cleanup, and reports [skip ci]"
          git push
          echo "âœ… Changes committed and pushed"
        else
          echo "âœ¨ No changes to commit"
        fi

    # === à¸ªà¸£à¹‰à¸²à¸‡ Summary Report ===
    - name: Generate Summary Report
      run: |
        echo "ðŸ“Š Generating summary report..."
        
        node -e "
        const fs = require('fs');
        
        const summary = {
          timestamp: new Date().toLocaleString('th-TH'),
          actions: {
            cleanup: 'Completed',
            documentation: 'Updated',
            healthCheck: 'Completed',
            apiDocs: 'Generated',
            performance: 'Analyzed'
          },
          nextSteps: [
            'Review health report for any issues',
            'Check performance recommendations',
            'Update documentation if needed'
          ]
        };
        
        let report = '# ðŸš€ GitHub Actions Summary Report\n\n';
        report += \`**Execution Time**: \${summary.timestamp}\n\n\`;
        
        report += '## âœ… Actions Completed\n\n';
        Object.entries(summary.actions).forEach(([action, status]) => {
          report += \`- **\${action}**: \${status}\n\`;
        });
        
        report += '\n## ðŸ“‹ Next Steps\n\n';
        summary.nextSteps.forEach(step => {
          report += \`- \${step}\n\`;
        });
        
        report += '\n---\n*Generated by Smart Documentation Sync*';
        
        fs.writeFileSync('.github/summary-report.md', report);
        console.log('ðŸ“Š Summary report generated');
        console.log(report);
        "

